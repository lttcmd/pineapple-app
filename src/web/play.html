<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Play ‚Äì OFC Pineapple</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f1115; --fg:#e7e8ea; --muted:#9aa3b2; --accent:#7ee787; --warn:#ffb86b; --drop:#212636; }
    body { margin:12px; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    h2 { margin: 6px 0 10px; }
    .topbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .pill { padding:2px 8px; background:#1b2030; border:1px solid #2a3244; border-radius:999px; color:#b7c1d6; }
    .muted { color:#9aa3b2; }
    button { background:#23293a; color:#e7e8ea; border:1px solid #2a3244; border-radius:8px; padding:8px 12px; cursor:pointer; }
    button:hover { border-color:#3b455f; }
    button[disabled] { opacity:.5; cursor:not-allowed; }
    .grid { display:grid; grid-template-columns: 1fr 360px; gap:12px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    /* Board */
    .board { display:grid; grid-template-columns: 1fr; gap:10px; }
    .zone { background:var(--drop); border:1px dashed #39415a; border-radius:10px; padding:8px; min-height:64px; }
    .zone h4 { margin:0 0 6px; color:#b7c1d6; font-weight:600; font-size:14px; display:flex; justify-content:space-between; }
    .rowline { display:flex; gap:6px; flex-wrap:wrap; min-height:48px; }
    .subcap { color:#8ea2c6; font-size:12px; margin-bottom:4px; }
    .zone.dragover { outline:2px solid var(--accent); outline-offset:0; }

    /* Hand & Card */
    .hand { display:flex; gap:8px; flex-wrap:wrap; }
    .card {
      display:inline-flex; align-items:center; justify-content:center;
      width:48px; height:64px; border-radius:6px;
      background:linear-gradient(180deg,#22283a,#1b2031);
      border:1px solid #313b55; user-select:none; cursor:grab;
      font-weight:700; font-size:1.05rem;
      transition: box-shadow .2s ease;
    }
    .card:active { cursor:grabbing; }
    .newcard { box-shadow: 0 0 0 2px rgba(126,231,135,.4), 0 0 12px rgba(126,231,135,.35) inset; }

    /* Suit colors */
    .card.hearts   { color: #ff4d4d; }
    .card.diamonds { color: #68a0ff; }
    .card.clubs    { color: #66d06f; }
    .card.spades   { color: #e7e8ea; }

    /* Timer bar */
    .timer-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: #2a3244;
      z-index: 1000;
    }
    .timer-bar-fill {
      height: 100%;
      background: #7ee787;
      transition: width 0.1s ease, background-color 0.1s ease;
    }
    .timer-bar-fill.warning {
      background: #ffb86b;
    }
    .timer-bar-fill.danger {
      background: #ff4444;
    }

    /* Right column */
    #log { white-space:pre-wrap; background:#0b0e17; border:1px solid #2a3244; border-radius:10px; padding:10px; min-height:120px; color:#b9f6ca; }
    .small { font-size:12px; color:#b7c1d6; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #2a3244; padding:6px; text-align:left; vertical-align:top; }
    th { color:#9fb0d1; font-weight:600; }
    .reveal-board { margin:6px 0 10px; }
    .rubric { color:#a9b7d6; }
  </style>
</head>
<body>
  <div class="topbar">
    <span id="conn" class="pill">connecting‚Ä¶</span>
    <span>Room:</span> <span id="roomPill" class="pill">‚Äî</span>
    <span>Phase:</span> <span id="phase" class="pill">‚Äî</span>
    <span>Round:</span> <span id="currentRound" class="pill">‚Äî</span>
    <span>Timer:</span> <span id="timer" class="pill">‚Äî</span>
    <button id="ready" disabled>Ready</button>
  </div>

  <!-- Timer bar -->
  <div class="timer-bar">
    <div class="timer-bar-fill" id="timerBarFill"></div>
  </div>

  <div class="grid">
    <div>
      <div class="board">
        <div id="zoneTop" class="zone" data-row="top">
          <h4>Top <span class="muted">limit 3</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" data-limit="3"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" data-limit="3"></div>
        </div>
        <div id="zoneMiddle" class="zone" data-row="middle">
          <h4>Middle <span class="muted">limit 5</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" data-limit="5"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" data-limit="5"></div>
        </div>
        <div id="zoneBottom" class="zone" data-row="bottom">
          <h4>Bottom <span class="muted">limit 5</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" data-limit="5"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" data-limit="5"></div>
        </div>
        <div id="zoneDiscard" class="zone" data-discard="true">
          <h4>Discard <span class="muted">(auto each pineapple round)</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" id="discardCommitted"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" id="discardStaged"></div>
        </div>
        

      </div>

      <h4 style="margin:12px 0 6px;">Your Hand</h4>
      <div id="hand" class="hand"></div>
    </div>



    <div>
      <fieldset style="border:1px solid #2a3244; border-radius:10px; padding:10px;">
        <legend>Players</legend>
        <div id="playerInfo" class="small">
          <div>Loading player info...</div>
        </div>
      </fieldset>

      <fieldset style="border:1px solid #2a3244; border-radius:10px; padding:10px;">
        <legend>Reveal & Scores</legend>
        <div class="small">Current totals (client-side):</div>
        <table id="scoreboard">
          <thead><tr><th>Player</th><th>Total</th></tr></thead>
          <tbody></tbody>
        </table>
        <div id="revealPanel" class="small" style="margin-top:8px;">‚Äî</div>
      </fieldset>

      <fieldset style="border:1px solid #2a3244; border-radius:10px; padding:10px; margin-top:12px;">
        <legend>Log</legend>
        <pre id="log"></pre>
      </fieldset>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // --- utilities
    const $ = id => document.getElementById(id);
    const qs = new URLSearchParams(location.search);
    const roomId = qs.get('room') || '';
    const myName = qs.get('name') || 'Player';
    if (!roomId) { alert('Missing room code. Going back to lobby.'); location.href='/lobby.html'; }

    const token = localStorage.getItem('ofc_jwt');
    if (!token) { location.href = '/auth/phone.html'; }

    // --- state
    let socket = null, myUserId = null;
    let currentPhase = 'lobby';
    let currentRound = 1; // Track current round for ready button logic
    let myHand = [], myBoard = { top:[], middle:[], bottom:[] }, myDiscards = [];
    let staged = { placements:[], discard:null };
    let lastBatch = [];
    let myFantasyland = false; // Track if current player is in fantasyland
    const totals = new Map();
    const nextRoundReady = new Set(); // Set of userIds ready for next round
    let roomState = null; // Store full room state for player info
    let isRanked = false; // Track if this is a ranked match
    
    // --- rendering helpers
    function suitClass(s){ return s==='h'?'hearts':s==='d'?'diamonds':s==='c'?'clubs':'spades'; }
    function suitSymbol(s){ return s==='h'?'‚ô•':s==='d'?'‚ô¶':s==='c'?'‚ô£':'‚ô†'; }
    


    function cardEl(code, isNew=false, source=null){
      const rank = code.slice(0,-1), suit = code.slice(-1);
      const el = document.createElement('div');
      el.className = `card ${suitClass(suit)} ${isNew?'newcard':''}`;
      el.textContent = `${rank}${suitSymbol(suit)}`;
      el.draggable = true;
      el.dataset.card = code;
      if (source) {
        el.dataset.source = source; // 'hand', 'board-top', 'board-middle', 'board-bottom', 'staged'
      }
      el.addEventListener('dragstart', (e)=> {
        e.dataTransfer.setData('text/plain', code);
        e.dataTransfer.setData('source', source || 'hand');
        e.dataTransfer.dropEffect = 'move';
      });
      return el;
    }

    function renderHand() {
      const wrap = $('hand'); wrap.innerHTML = '';
      myHand.forEach(c => wrap.appendChild(cardEl(c, lastBatch.includes(c), 'hand')));
    }
    function renderRow(zoneId, committedCards, stagedCards) {
      const zone = $(zoneId), cWrap = zone.querySelector('.committed'), sWrap = zone.querySelector('.staged');
      cWrap.innerHTML = ''; sWrap.innerHTML = '';
      committedCards.forEach(c => cWrap.appendChild(cardEl(c, false, `board-${zone.dataset.row}`)));
      stagedCards.forEach(c => sWrap.appendChild(cardEl(c, false, 'staged')));
    }
    function getStagedByRow(row){ return staged.placements.filter(x=>x.row===row).map(x=>x.card); }
    function refreshBoard(){
      renderRow('zoneTop', myBoard.top, getStagedByRow('top'));
      renderRow('zoneMiddle', myBoard.middle, getStagedByRow('middle'));
      renderRow('zoneBottom', myBoard.bottom, getStagedByRow('bottom'));
      const dc = $('discardCommitted'); dc.innerHTML=''; myDiscards.forEach(c => dc.appendChild(cardEl(c, false, 'discard')));
      const ds = $('discardStaged'); ds.innerHTML=''; if (staged.discard) ds.appendChild(cardEl(staged.discard, false, 'staged-discard'));
      const canSetResult = canSet();
      console.log("üéØ WEB APP: Setting ready button disabled =", !canSetResult);
      $('ready').disabled = !canSetResult;
    }

    // drop targets
    function installDrop(zoneId){
      const zone = $(zoneId);
      zone.addEventListener('dragover', (e)=>{ e.preventDefault(); zone.classList.add('dragover'); });
      zone.addEventListener('dragleave', ()=> zone.classList.remove('dragover'));
      zone.addEventListener('drop', (e)=>{
        e.preventDefault(); zone.classList.remove('dragover');
        const code = e.dataTransfer.getData('text/plain');
        const source = e.dataTransfer.getData('source');
        if (!code) return;

        const isDiscard = zone.dataset.discard === 'true';
        
        // Handle re-dragging from board positions
        if (source && source.startsWith('board-')) {
          const sourceRow = source.replace('board-', '');
          
          // Remove from source position
          if (sourceRow === zone.dataset.row) {
            // Same row - just move within the row (no action needed for staged cards)
            return;
          }
          
          // Remove from committed board
          if (myBoard[sourceRow].includes(code)) {
            myBoard[sourceRow] = myBoard[sourceRow].filter(c => c !== code);
          }
          
          // Remove from staged placements
          staged.placements = staged.placements.filter(p => !(p.row === sourceRow && p.card === code));
          
          // Add to hand for re-placement
          if (!myHand.includes(code)) {
            myHand.push(code);
          }
          
          renderHand(); refreshBoard(); return;
        }
        
        // Handle re-dragging from staged cards
        if (source === 'staged') {
          // Remove from staged placements
          staged.placements = staged.placements.filter(p => p.card !== code);
          
          // Add to hand for re-placement
          if (!myHand.includes(code)) {
            myHand.push(code);
          }
          
          renderHand(); refreshBoard(); return;
        }
        
        // Handle re-dragging from discard zones
        if (source === 'discard' || source === 'staged-discard') {
          // Remove from staged discard
          if (staged.discard === code) {
            staged.discard = null;
          }
          
          // Add to hand for re-placement
          if (!myHand.includes(code)) {
            myHand.push(code);
          }
          
          renderHand(); refreshBoard(); return;
        }

        if (currentPhase === 'round' && !lastBatch.includes(code)) {
          alert('This step: only the new cards can be used.'); return;
        }

        if (isDiscard) {
          if (staged.discard) return alert('Discard already staged');
          if (!myHand.includes(code)) return;
          myHand = myHand.filter(c => c!==code);
          staged.discard = code;
          renderHand(); refreshBoard(); return;
        }

        const row = zone.dataset.row;
        if (!myHand.includes(code)) return;
        const limit = row==='top'?3:5;
        const current = myBoard[row].length + getStagedByRow(row).length;
        if (current >= limit) return alert(`${row} full`);

        myHand = myHand.filter(c => c!==code);
        staged.placements.push({ row, card: code });
        renderHand(); refreshBoard();
      });
    }
    ['zoneTop','zoneMiddle','zoneBottom','zoneDiscard'].forEach(installDrop);

    // batch validity - exactly like mobile app
    function canSet(){
      // Calculate needed cards like mobile app
      const needed = myFantasyland ? 13 : (currentRound === 1 ? 5 : 2);
      const stagedCount = staged.placements.length;
      const canPress = stagedCount === needed;
      
      console.log("üéØ WEB APP: canSet() called - myFantasyland:", myFantasyland, "currentRound:", currentRound, "needed:", needed, "stagedCount:", stagedCount, "canPress:", canPress, "staged.placements:", staged.placements);
      
      return canPress;
    }
    
    // fantasyland validity - must place all 14 cards
    function canSetFantasyland(){
      if (currentPhase === 'round') {
        // In fantasyland, must place all 14 cards (no discards)
        return myHand.length === 0;
      }
      return false;
    }

    // buttons
 $('ready').onclick = () => {
  console.log("üéØ WEB APP: Ready button clicked!");
  if (!socket) return alert('Connect first');

  // Auto-discard logic exactly like mobile app
  const placedSet = new Set(staged.placements.map(p => p.card));
  let leftover = null;
  if (!myFantasyland) {
    // Normal mode: auto-discard leftover card
    leftover = (myHand || []).find(c => !placedSet.has(c)) || null;
    console.log("üéØ WEB APP: onCommit - hand:", myHand, "placedSet:", Array.from(placedSet), "leftover:", leftover);
  } else {
    // Fantasyland mode: auto-discard leftover card (1 card should be discarded)
    leftover = (myHand || []).find(c => !placedSet.has(c)) || null;
    console.log("üéØ WEB APP: onCommit - fantasyland hand:", myHand, "placedSet:", Array.from(placedSet), "leftover:", leftover);
  }

  // send to server
  const readyData = {
    roomId,
    placements: staged.placements,
    discard: leftover || undefined,
    userId: myUserId
  };
  console.log("üéØ WEB APP: Emitting action:ready with data:", readyData);
  console.log("üéØ WEB APP: onCommit - myFantasyland:", myFantasyland, "leftover:", leftover, "final discard value:", readyData.discard);
  socket.emit("action:ready", readyData);

  // optimistic commit
  for (const p of staged.placements) myBoard[p.row].push(p.card);
  if (staged.discard) myDiscards.push(staged.discard);

  // IMPORTANT: clear the current batch only AFTER committing
  lastBatch = [];

  // reset staging and refresh UI
  staged = { placements: [], discard: null };
  renderHand();
  refreshBoard();
};

    // scoreboard / reveal
    function renderPlayerInfo() {
      if (!roomState || !roomState.players) return;
      
      const playerInfo = $('playerInfo');
      playerInfo.innerHTML = '';
      
      // Handle both old and new player data structures
      roomState.players.forEach(player => {
        const playerDiv = document.createElement('div');
        playerDiv.style.marginBottom = '8px';
        playerDiv.style.padding = '6px';
        playerDiv.style.border = '1px solid #2a3244';
        playerDiv.style.borderRadius = '6px';
        playerDiv.style.backgroundColor = player.userId === myUserId ? '#1b2030' : '#0b0e17';
        
        const nameSpan = document.createElement('div');
        nameSpan.style.fontWeight = 'bold';
        nameSpan.style.color = '#e7e8ea';
        nameSpan.textContent = player.name || player.userId;
        
        const infoSpan = document.createElement('div');
        infoSpan.style.color = '#9aa3b2';
        infoSpan.style.fontSize = '12px';
        
        // Handle new GameEngine player structure
        if (isRanked && player.tableChips !== undefined) {
          infoSpan.textContent = `${player.tableChips} chips`;
        } else {
          infoSpan.textContent = `Score: ${player.score || 0}`;
        }
        
        // Add ready status indicator
        if (player.ready) {
          const readySpan = document.createElement('div');
          readySpan.style.color = '#4ade80';
          readySpan.style.fontSize = '10px';
          readySpan.textContent = '‚úì Ready';
          playerDiv.appendChild(readySpan);
        }
        
        // Add fantasyland indicator
        if (player.inFantasyland) {
          const fantasySpan = document.createElement('div');
          fantasySpan.style.color = '#fbbf24';
          fantasySpan.style.fontSize = '10px';
          fantasySpan.textContent = 'üåü Fantasyland';
          playerDiv.appendChild(fantasySpan);
        }
        
        playerDiv.appendChild(nameSpan);
        playerDiv.appendChild(infoSpan);
        playerInfo.appendChild(playerDiv);
      });
    }
    
    function renderScoreboard(names) {
      const tbody = $('scoreboard').querySelector('tbody'); tbody.innerHTML='';
      [...totals.entries()].sort((a,b)=>b[1]-a[1]).forEach(([uid,score])=>{
        const tr=document.createElement('tr'); const tdN=document.createElement('td'); const tdS=document.createElement('td');
        tdN.textContent = names.get(uid) || uid.slice(0,8); tdS.textContent = String(score);
        tr.appendChild(tdN); tr.appendChild(tdS); tbody.appendChild(tr);
      });
    }
    function tinyCardsDiv(cards){ const d=document.createElement('div'); cards.forEach(c=>d.appendChild(cardEl(c))); return d; }
    function boardBlock(title, board, valid, reason){
      const wrap=document.createElement('div'); wrap.className='reveal-board';
      const h=document.createElement('div'); h.innerHTML = `<strong>${title}</strong> ${valid?'':`<span class="rubric">[FOUL: ${reason}]</span>`}`; wrap.appendChild(h);
      const tbl=document.createElement('table'); const tb=document.createElement('tbody');
      const mk=(label,arr)=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${label}</td><td></td>`; tr.children[1].appendChild(tinyCardsDiv(arr)); tb.appendChild(tr); };
      mk('Top',board.top); mk('Middle',board.middle); mk('Bottom',board.bottom);
      tbl.appendChild(tb); wrap.appendChild(tbl); return wrap;
    }
    function renderRevealPanel(meId, payload){
      const names = new Map(); for (const b of payload.boards) names.set(b.userId,b.name);
      // roll totals
      for (const [uid,pts] of Object.entries(payload.results||{})) totals.set(uid,(totals.get(uid)||0)+pts);
      renderScoreboard(names);

      const panel = $('revealPanel'); panel.innerHTML='';
      // boards (mine first)
      [...payload.boards].sort((a,b)=>a.userId===meId?-1:b.userId===meId?1:0).forEach(b=>{
        panel.appendChild(boardBlock(b.name,b.board,b.valid,b.reason));
      });

      // my pairwise
      const myPairs = (payload.pairwise||[]).filter(p=>p.aUserId===meId||p.bUserId===meId);
      if (myPairs.length){
        const head=document.createElement('div'); head.innerHTML='<div style="margin-top:10px;"><strong>Score breakdown</strong></div>'; panel.appendChild(head);
      }
      myPairs.forEach(p=>{
        const mine = p.aUserId===meId ? p.a : p.b;
        const opp  = p.aUserId===meId ? p.b : p.a;
        const oppId= p.aUserId===meId ? p.bUserId : p.aUserId;
        
        // Calculate line scores with royalties
        const getLineScore = (d, line) => {
          const lineScore = d.lines[line] || 0;
          const royaltyScore = d.royaltiesBreakdown?.[line] || 0;
          return lineScore + royaltyScore;
        };
        
        const mineTop = getLineScore(mine, 'top');
        const mineMiddle = getLineScore(mine, 'middle');
        const mineBottom = getLineScore(mine, 'bottom');
        const mineScoop = mine.scoop || 0;
        const mineTotal = mineTop + mineMiddle + mineBottom + mineScoop;
        
        const oppTop = getLineScore(opp, 'top');
        const oppMiddle = getLineScore(opp, 'middle');
        const oppBottom = getLineScore(opp, 'bottom');
        const oppScoop = opp.scoop || 0;
        const oppTotal = oppTop + oppMiddle + oppBottom + oppScoop;
        
        // Calculate difference and chip conversion
        const difference = mineTotal - oppTotal;
        const chipDifference = difference * 10;
        
        const sec=document.createElement('div');
        sec.innerHTML = `
          <div style="margin-top:10px;margin-bottom:8px;padding:8px;background:#1b2030;border-radius:8px;border:1px solid #2a3244;">
            <div style="margin-bottom:8px;"><strong>Vs ${names.get(oppId) || oppId.slice(0,8)}</strong></div>
            
            <!-- Line Scores -->
            <div style="margin-bottom:12px;">
              <div style="font-weight:600;margin-bottom:6px;color:#9aa3b2;">Line Scores:</div>
              <table style="width:100%;font-size:14px;">
                <thead><tr><th style="text-align:left;">Line</th><th style="text-align:right;">You</th><th style="text-align:right;">Opponent</th></tr></thead>
                <tbody>
                  <tr><td>Top</td><td style="text-align:right;">${mineTop>=0?'+':''}${mineTop}</td><td style="text-align:right;">${oppTop>=0?'+':''}${oppTop}</td></tr>
                  <tr><td>Middle</td><td style="text-align:right;">${mineMiddle>=0?'+':''}${mineMiddle}</td><td style="text-align:right;">${oppMiddle>=0?'+':''}${oppMiddle}</td></tr>
                  <tr><td>Bottom</td><td style="text-align:right;">${mineBottom>=0?'+':''}${mineBottom}</td><td style="text-align:right;">${oppBottom>=0?'+':''}${oppBottom}</td></tr>
                  ${mineScoop > 0 || oppScoop > 0 ? `<tr><td>Scoop Bonus</td><td style="text-align:right;">${mineScoop>=0?'+':''}${mineScoop}</td><td style="text-align:right;">${oppScoop>=0?'+':''}${oppScoop}</td></tr>` : ''}
                  <tr style="border-top:1px solid #2a3244;font-weight:600;">
                    <td>Total</td><td style="text-align:right;">${mineTotal>=0?'+':''}${mineTotal}</td><td style="text-align:right;">${oppTotal>=0?'+':''}${oppTotal}</td></tr>
                </tbody>
              </table>
            </div>
            
            <!-- Difference -->
            <div style="margin-bottom:8px;padding-top:8px;border-top:1px solid #2a3244;">
              <div style="font-weight:600;margin-bottom:4px;color:#9aa3b2;">Difference:</div>
              <div style="font-size:16px;font-weight:700;text-align:center;color:${difference>=0?'#7ee787':'#ff6b6b'}">
                ${difference>=0?'+':''}${difference} points
              </div>
            </div>
            
            ${isRanked ? `
            <!-- Chip Conversion for Ranked Matches -->
            <div style="padding-top:8px;border-top:1px solid #2a3244;">
              <div style="font-weight:600;margin-bottom:4px;color:#9aa3b2;">Chip Conversion (1 point = 10 chips):</div>
              <div style="font-size:16px;font-weight:700;text-align:center;color:${chipDifference>=0?'#7ee787':'#ff6b6b'}">
                ${chipDifference>=0?'+':''}${chipDifference} chips
              </div>
            </div>
            ` : ''}
          </div>`;
        panel.appendChild(sec);
      });
    }

    // socket
    function setPhase(p){ currentPhase=p||'‚Äî'; $('phase').textContent=currentPhase; $('ready').disabled=!canSet(); }
    function setCurrentRound(r){ $('currentRound').textContent=r||'‚Äî'; }
    function log(m){ $('log').textContent += m + "\n"; }

    socket = io("/", { auth:{ token } });
    socket.on('connect', () => {
      $('conn').textContent='connected';
      $('roomPill').textContent = roomId;
      
      // Check if this is a ranked match (from URL parameter)
      const urlParams = new URLSearchParams(window.location.search);
      isRanked = urlParams.get('ranked') === 'true';
      
      if (!isRanked) {
        // Only join room if it's not a ranked match (ranked matches auto-join)
        socket.emit("room:join", { roomId, name: myName });
      }
      
      // Reset next round ready state
      nextRoundReady.clear();
      updateStartButton();
    });
    socket.on('disconnect', ()=> $('conn').textContent='disconnected');
    socket.on("auth:ok", (x)=>{ myUserId = x?.userId || myUserId; });

    socket.on("room:state", (s)=>{ 
      console.log("üéØ WEB APP: Received room:state event:", s);
      roomState = s; // Store full room state
      isRanked = s.isRanked || false; // Track if this is a ranked match
      setPhase(s.phase); 
      setCurrentRound(s.currentRound);
      renderPlayerInfo(); // Update player info display
      log("STATE\n"+JSON.stringify(s,null,2)); 
      updateStartButton();
    });
    
    socket.on("player:state", (data) => {
      console.log("üéØ WEB APP: Received player:state event:", data);
      if (data.userId === myUserId) {
        // Update local player state
        myBoard = data.board;
        myHand = data.hand;
        myDiscards = data.discards;
        
        // Update UI
        renderHand();
        refreshBoard();
        
        log(`Player state updated: Hand(${myHand.length}), Board(T:${myBoard.top.length},M:${myBoard.middle.length},B:${myBoard.bottom.length})`);
      }
    });
    socket.on("round:start", ({round})=>{
      console.log("Round start:", round);
      myBoard={top:[],middle:[],bottom:[]}; myDiscards=[]; staged={placements:[],discard:null}; lastBatch=[];
      myFantasyland = false; // Reset fantasyland status
      $('revealPanel').textContent='‚Äî'; renderHand(); refreshBoard(); log("START round "+round);
      // Reset next round ready state
      nextRoundReady.clear();
      updateStartButton();
    });
    socket.on("round:deal", ({cards, fantasyland, round})=>{
      console.log("üéØ WEB APP: Received round:deal event:", {cards, fantasyland, round});
      lastBatch = cards.slice(); 
      myHand = myHand.concat(cards); 
      myFantasyland = fantasyland; // Store fantasyland status
      currentRound = round; // Update current round for canSet() function
      renderHand();
      
      if (fantasyland) {
        // Fantasyland mode: 14 cards, no discard button, 2 rows of 7 cards
        log("FANTASY LAND MODE: 14 cards dealt");
        $('ready').disabled = !canSet();
        
        // Hide discard zone for fantasyland
        $('zoneDiscard').style.display = 'none';
        
        // Update UI to show fantasyland mode
        document.body.style.backgroundColor = '#fff3cd';
        setTimeout(() => {
          document.body.style.backgroundColor = '';
        }, 1000);
      } else {
        // Normal mode: check if this is round 1 (5 cards) or other rounds (3 cards)
        if (round === 1) {
          // Round 1: 5 cards, must place all 5
          log("ROUND 1: 5 cards dealt, must place all");
          const canSetResult1 = canSet();
          console.log("üéØ WEB APP: Round 1 - Setting ready button disabled =", !canSetResult1);
          $('ready').disabled = !canSetResult1;
          $('zoneDiscard').style.display = 'none'; // No discard in round 1
        } else {
          // Rounds 2-5: 3 cards, place 2 discard 1
          log(`ROUND ${round}: 3 cards dealt, place 2 discard 1`);
          const canSetResult2 = canSet();
          console.log("üéØ WEB APP: Round", round, "- Setting ready button disabled =", !canSetResult2);
          $('ready').disabled = !canSetResult2;
          $('zoneDiscard').style.display = 'block';
        }
      }
      
      log("DEAL "+JSON.stringify(cards) + (fantasyland ? " (FANTASY LAND)" : ` (ROUND ${round})`));
    });
    socket.on("round:reveal", (payload)=>{
      log("REVEAL\n"+JSON.stringify(payload,null,2));
      if (myUserId) renderRevealPanel(myUserId, payload);
      // reset staged so next hand starts clean
      staged={placements:[],discard:null}; $('ready').disabled=true;
      // Reset next round ready state
      nextRoundReady.clear();
      updateStartButton();
    });

    socket.on("round:next-ready", (data) => {
      nextRoundReady.clear();
      if (data?.readyPlayers) {
        data.readyPlayers.forEach(id => nextRoundReady.add(id));
      }
      updateStartButton();
      log("Next round ready update: " + [...nextRoundReady].join(', '));
    });
    
    // Timer events
    socket.on("timer:start", (timerInfo) => {
      console.log("üéØ WEB APP: Timer started:", timerInfo);
      log(`Timer started: ${timerInfo.durationMs}ms`);
    });
    
    socket.on("timer:expired", () => {
      console.log("üéØ WEB APP: Timer expired");
      log("Timer expired - auto-placing cards");
    });
    
    socket.on("timer:update", (timerInfo) => {
      console.log("üéØ WEB APP: Timer update:", timerInfo);
      // Update timer display if needed
    });

    // Function to update start button text and state
    function updateStartButton() {
      const startBtn = $('start');
      if (currentPhase === 'lobby') {
        if (nextRoundReady.has(myUserId)) {
          startBtn.textContent = 'Waiting for opponent...';
          startBtn.disabled = true;
        } else {
          startBtn.textContent = 'Ready';
          startBtn.disabled = false;
        }
      } else if (currentPhase === 'reveal') {
        startBtn.textContent = 'Reveal';
        startBtn.disabled = true;
      } else {
        startBtn.textContent = 'Start Round';
        startBtn.disabled = false;
      }
    }

    // Handle auto-commit notification
    socket.on("action:applied", (data) => {
      console.log("Action applied received:", data);
      
      if (data.autoCommitted) {
        console.log("üéØ AUTO-COMMIT PUNISHMENT DETECTED!");
        console.log("Previous state:", {
          hand: myHand,
          board: myBoard,
          discards: myDiscards,
          staged: staged
        });
        
        // Update local state with auto-committed cards
        myBoard = data.board;
        myHand = data.hand;
        myDiscards = data.discards;
        
        // Clear staged state since cards were auto-committed
        staged = { placements: [], discard: null };
        lastBatch = [];
        
        console.log("New state after auto-commit:", {
          hand: myHand,
          board: myBoard,
          discards: myDiscards,
          staged: staged
        });
        
        // Update UI
        renderHand();
        refreshBoard();
        
        // Add visual feedback
        log("‚è∞ TIMEOUT PUNISHMENT: Cards auto-committed!");
        log(`Board updated: Top(${myBoard.top.length}), Middle(${myBoard.middle.length}), Bottom(${myBoard.bottom.length})`);
        if (myDiscards.length > 0) {
          log(`Discarded: ${myDiscards.join(', ')}`);
        }
        
        // Add visual flash effect to show auto-commit happened
        document.body.style.backgroundColor = '#ff4444';
        setTimeout(() => {
          document.body.style.backgroundColor = '';
        }, 500);
      }
    });


    // Timer handling
    let timerInterval = null;
    let timerDeadline = null;
    let timerDuration = null;
    let timerPhaseType = null;

    socket.on("timer:start", (data) => {
      console.log("üéØ WEB APP: Timer started:", data);
      timerDeadline = data.deadlineEpochMs;
      timerDuration = data.durationMs;
      timerPhaseType = data.phaseType;
      
      // Clear any existing timer
      if (timerInterval) {
        clearInterval(timerInterval);
      }
      
      // Start timer countdown
      timerInterval = setInterval(() => {
        updateTimerDisplay();
      }, 100); // Update every 100ms for smooth countdown
      
      updateTimerDisplay();
      log(`‚è∞ Timer started: ${timerPhaseType} (${Math.round(timerDuration/1000)}s)`);
    });

    socket.on("timer:expired", (data) => {
      console.log("üéØ WEB APP: Timer expired:", data);
      
      // Clear timer
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      
      timerDeadline = null;
      timerDuration = null;
      timerPhaseType = null;
      
      updateTimerDisplay();
      log("‚è∞ Timer expired!");
    });

    function updateTimerDisplay() {
      const timerElement = $('timer');
      const timerBarFill = $('timerBarFill');
      
      if (!timerDeadline) {
        timerElement.textContent = '‚Äî';
        timerBarFill.style.width = '0%';
        timerBarFill.className = 'timer-bar-fill';
        return;
      }
      
      const now = Date.now();
      const remaining = Math.max(0, timerDeadline - now);
      const seconds = Math.ceil(remaining / 1000);
      
      // Calculate progress (0.0 to 1.0)
      const progress = Math.max(0, Math.min(1, remaining / timerDuration));
      const progressPercent = (progress * 100) + '%';
      
      // Color coding based on remaining time
      let color = '#7ee787'; // Green (default)
      let barClass = '';
      
      if (remaining <= timerDuration * 0.25) {
        color = '#ff4444'; // Red (25% or less)
        barClass = 'danger';
      } else if (remaining <= timerDuration * 0.5) {
        color = '#ffb86b'; // Yellow (50% or less)
        barClass = 'warning';
      }
      
      timerElement.textContent = `${seconds}s`;
      timerElement.style.color = color;
      
      // Update timer bar
      timerBarFill.style.width = progressPercent;
      timerBarFill.className = `timer-bar-fill ${barClass}`;
      
      // Stop timer if expired
      if (remaining <= 0 && timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    socket.on("error:msg", (e)=> log("ERROR "+e.message));
  </script>
</body>
</html>
