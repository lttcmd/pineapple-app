<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Play – OFC Pineapple</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f1115; --fg:#e7e8ea; --muted:#9aa3b2; --accent:#7ee787; --warn:#ffb86b; --drop:#212636; }
    body { margin:12px; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    h2 { margin: 6px 0 10px; }
    .topbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .pill { padding:2px 8px; background:#1b2030; border:1px solid #2a3244; border-radius:999px; color:#b7c1d6; }
    .muted { color:#9aa3b2; }
    button { background:#23293a; color:#e7e8ea; border:1px solid #2a3244; border-radius:8px; padding:8px 12px; cursor:pointer; }
    button:hover { border-color:#3b455f; }
    button[disabled] { opacity:.5; cursor:not-allowed; }
    .grid { display:grid; grid-template-columns: 1fr 360px; gap:12px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    /* Board */
    .board { display:grid; grid-template-columns: 1fr; gap:10px; }
    .zone { background:var(--drop); border:1px dashed #39415a; border-radius:10px; padding:8px; min-height:64px; }
    .zone h4 { margin:0 0 6px; color:#b7c1d6; font-weight:600; font-size:14px; display:flex; justify-content:space-between; }
    .rowline { display:flex; gap:6px; flex-wrap:wrap; min-height:48px; }
    .subcap { color:#8ea2c6; font-size:12px; margin-bottom:4px; }
    .zone.dragover { outline:2px solid var(--accent); outline-offset:0; }

    /* Hand & Card */
    .hand { display:flex; gap:8px; flex-wrap:wrap; }
    .card {
      display:inline-flex; align-items:center; justify-content:center;
      width:48px; height:64px; border-radius:6px;
      background:linear-gradient(180deg,#22283a,#1b2031);
      border:1px solid #313b55; user-select:none; cursor:grab;
      font-weight:700; font-size:1.05rem;
      transition: box-shadow .2s ease;
    }
    .card:active { cursor:grabbing; }
    .newcard { box-shadow: 0 0 0 2px rgba(126,231,135,.4), 0 0 12px rgba(126,231,135,.35) inset; }

    /* Suit colors */
    .card.hearts   { color: #ff4d4d; }
    .card.diamonds { color: #68a0ff; }
    .card.clubs    { color: #66d06f; }
    .card.spades   { color: #e7e8ea; }



    /* Right column */
    #log { white-space:pre-wrap; background:#0b0e17; border:1px solid #2a3244; border-radius:10px; padding:10px; min-height:120px; color:#b9f6ca; }
    .small { font-size:12px; color:#b7c1d6; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #2a3244; padding:6px; text-align:left; vertical-align:top; }
    th { color:#9fb0d1; font-weight:600; }
    .reveal-board { margin:6px 0 10px; }
    .rubric { color:#a9b7d6; }
  </style>
</head>
<body>
  <div class="topbar">
    <span id="conn" class="pill">connecting…</span>
    <span>Room:</span> <span id="roomPill" class="pill">—</span>
    <span>Phase:</span> <span id="phase" class="pill">—</span>
    <span>Round:</span> <span id="currentRound" class="pill">—</span>
    <button id="start">Start Round</button>
    <button id="ready" disabled>Send Batch + Ready</button>
  </div>

  <div class="grid">
    <div>
      <div class="board">
        <div id="zoneTop" class="zone" data-row="top">
          <h4>Top <span class="muted">limit 3</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" data-limit="3"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" data-limit="3"></div>
        </div>
        <div id="zoneMiddle" class="zone" data-row="middle">
          <h4>Middle <span class="muted">limit 5</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" data-limit="5"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" data-limit="5"></div>
        </div>
        <div id="zoneBottom" class="zone" data-row="bottom">
          <h4>Bottom <span class="muted">limit 5</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" data-limit="5"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" data-limit="5"></div>
        </div>
        <div id="zoneDiscard" class="zone" data-discard="true">
          <h4>Discard <span class="muted">(auto each pineapple round)</span></h4>
          <div class="subcap">Committed</div>
          <div class="rowline committed" id="discardCommitted"></div>
          <div class="subcap">Staged</div>
          <div class="rowline staged" id="discardStaged"></div>
        </div>
        

      </div>

      <h4 style="margin:12px 0 6px;">Your Hand</h4>
      <div id="hand" class="hand"></div>
    </div>



    <div>
      <fieldset style="border:1px solid #2a3244; border-radius:10px; padding:10px;">
        <legend>Players</legend>
        <div id="playerInfo" class="small">
          <div>Loading player info...</div>
        </div>
      </fieldset>

      <fieldset style="border:1px solid #2a3244; border-radius:10px; padding:10px;">
        <legend>Reveal & Scores</legend>
        <div class="small">Current totals (client-side):</div>
        <table id="scoreboard">
          <thead><tr><th>Player</th><th>Total</th></tr></thead>
          <tbody></tbody>
        </table>
        <div id="revealPanel" class="small" style="margin-top:8px;">—</div>
      </fieldset>

      <fieldset style="border:1px solid #2a3244; border-radius:10px; padding:10px; margin-top:12px;">
        <legend>Log</legend>
        <pre id="log"></pre>
      </fieldset>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // --- utilities
    const $ = id => document.getElementById(id);
    const qs = new URLSearchParams(location.search);
    const roomId = qs.get('room') || '';
    const myName = qs.get('name') || 'Player';
    if (!roomId) { alert('Missing room code. Going back to lobby.'); location.href='/lobby.html'; }

    const token = localStorage.getItem('ofc_jwt');
    if (!token) { location.href = '/auth/phone.html'; }

    // --- state
    let socket = null, myUserId = null;
    let currentPhase = 'lobby';
    let myHand = [], myBoard = { top:[], middle:[], bottom:[] }, myDiscards = [];
    let staged = { placements:[], discard:null };
    let lastBatch = [];
    const totals = new Map();
    const nextRoundReady = new Set(); // Set of userIds ready for next round
    let roomState = null; // Store full room state for player info
    let isRanked = false; // Track if this is a ranked match
    
    // --- rendering helpers
    function suitClass(s){ return s==='h'?'hearts':s==='d'?'diamonds':s==='c'?'clubs':'spades'; }
    function suitSymbol(s){ return s==='h'?'♥':s==='d'?'♦':s==='c'?'♣':'♠'; }
    


    function cardEl(code, isNew=false, source=null){
      const rank = code.slice(0,-1), suit = code.slice(-1);
      const el = document.createElement('div');
      el.className = `card ${suitClass(suit)} ${isNew?'newcard':''}`;
      el.textContent = `${rank}${suitSymbol(suit)}`;
      el.draggable = true;
      el.dataset.card = code;
      if (source) {
        el.dataset.source = source; // 'hand', 'board-top', 'board-middle', 'board-bottom', 'staged'
      }
      el.addEventListener('dragstart', (e)=> {
        e.dataTransfer.setData('text/plain', code);
        e.dataTransfer.setData('source', source || 'hand');
        e.dataTransfer.dropEffect = 'move';
      });
      return el;
    }

    function renderHand() {
      const wrap = $('hand'); wrap.innerHTML = '';
      myHand.forEach(c => wrap.appendChild(cardEl(c, lastBatch.includes(c), 'hand')));
    }
    function renderRow(zoneId, committedCards, stagedCards) {
      const zone = $(zoneId), cWrap = zone.querySelector('.committed'), sWrap = zone.querySelector('.staged');
      cWrap.innerHTML = ''; sWrap.innerHTML = '';
      committedCards.forEach(c => cWrap.appendChild(cardEl(c, false, `board-${zone.dataset.row}`)));
      stagedCards.forEach(c => sWrap.appendChild(cardEl(c, false, 'staged')));
    }
    function getStagedByRow(row){ return staged.placements.filter(x=>x.row===row).map(x=>x.card); }
    function refreshBoard(){
      renderRow('zoneTop', myBoard.top, getStagedByRow('top'));
      renderRow('zoneMiddle', myBoard.middle, getStagedByRow('middle'));
      renderRow('zoneBottom', myBoard.bottom, getStagedByRow('bottom'));
      const dc = $('discardCommitted'); dc.innerHTML=''; myDiscards.forEach(c => dc.appendChild(cardEl(c, false, 'discard')));
      const ds = $('discardStaged'); ds.innerHTML=''; if (staged.discard) ds.appendChild(cardEl(staged.discard, false, 'staged-discard'));
      $('ready').disabled = !canSet();
    }

    // drop targets
    function installDrop(zoneId){
      const zone = $(zoneId);
      zone.addEventListener('dragover', (e)=>{ e.preventDefault(); zone.classList.add('dragover'); });
      zone.addEventListener('dragleave', ()=> zone.classList.remove('dragover'));
      zone.addEventListener('drop', (e)=>{
        e.preventDefault(); zone.classList.remove('dragover');
        const code = e.dataTransfer.getData('text/plain');
        const source = e.dataTransfer.getData('source');
        if (!code) return;

        const isDiscard = zone.dataset.discard === 'true';
        
        // Handle re-dragging from board positions
        if (source && source.startsWith('board-')) {
          const sourceRow = source.replace('board-', '');
          
          // Remove from source position
          if (sourceRow === zone.dataset.row) {
            // Same row - just move within the row (no action needed for staged cards)
            return;
          }
          
          // Remove from committed board
          if (myBoard[sourceRow].includes(code)) {
            myBoard[sourceRow] = myBoard[sourceRow].filter(c => c !== code);
          }
          
          // Remove from staged placements
          staged.placements = staged.placements.filter(p => !(p.row === sourceRow && p.card === code));
          
          // Add to hand for re-placement
          if (!myHand.includes(code)) {
            myHand.push(code);
          }
          
          renderHand(); refreshBoard(); return;
        }
        
        // Handle re-dragging from staged cards
        if (source === 'staged') {
          // Remove from staged placements
          staged.placements = staged.placements.filter(p => p.card !== code);
          
          // Add to hand for re-placement
          if (!myHand.includes(code)) {
            myHand.push(code);
          }
          
          renderHand(); refreshBoard(); return;
        }
        
        // Handle re-dragging from discard zones
        if (source === 'discard' || source === 'staged-discard') {
          // Remove from staged discard
          if (staged.discard === code) {
            staged.discard = null;
          }
          
          // Add to hand for re-placement
          if (!myHand.includes(code)) {
            myHand.push(code);
          }
          
          renderHand(); refreshBoard(); return;
        }

        if (currentPhase === 'round' && !lastBatch.includes(code)) {
          alert('This step: only the new cards can be used.'); return;
        }

        if (isDiscard) {
          if (staged.discard) return alert('Discard already staged');
          if (!myHand.includes(code)) return;
          myHand = myHand.filter(c => c!==code);
          staged.discard = code;
          renderHand(); refreshBoard(); return;
        }

        const row = zone.dataset.row;
        if (!myHand.includes(code)) return;
        const limit = row==='top'?3:5;
        const current = myBoard[row].length + getStagedByRow(row).length;
        if (current >= limit) return alert(`${row} full`);

        myHand = myHand.filter(c => c!==code);
        staged.placements.push({ row, card: code });
        renderHand(); refreshBoard();
      });
    }
    ['zoneTop','zoneMiddle','zoneBottom','zoneDiscard'].forEach(installDrop);

    // batch validity
    function canSet(){
      if (currentPhase === 'initial-set') {
        // must place all 5 dealt initially → we simply require empty hand after first deal
        // but safer: allow if no cards from first batch remain in hand
        return myHand.length === 0 || (myBoard.top.length + myBoard.middle.length + myBoard.bottom.length) >= 5;
      }
      if (currentPhase === 'round') {
        // Check if this is fantasyland mode (14 cards in lastBatch)
        if (lastBatch.length === 14) {
          // Fantasyland mode: must place all 14 cards, no discards
          return myHand.length === 0;
        }
        
        // Check if this is round 1 (5 cards) or other rounds (3 cards)
        if (lastBatch.length === 5) {
          // Round 1: must place all 5 cards, no discard
          return myHand.length === 0;
        } else if (lastBatch.length === 3) {
          // Rounds 2-5: must place exactly 2 of the 3 cards
          const placedFromBatch = staged.placements.filter(p => lastBatch.includes(p.card)).length;
          return placedFromBatch === 2; // discard auto if missing
        }
      }
      return false;
    }
    
    // fantasyland validity - must place all 14 cards
    function canSetFantasyland(){
      if (currentPhase === 'round') {
        // In fantasyland, must place all 14 cards (no discards)
        return myHand.length === 0;
      }
      return false;
    }

    // buttons
    $('start').onclick = () => {
      socket.emit("round:start", { roomId });
    };
 $('ready').onclick = () => {
  if (!socket) return alert('Connect first');

  if (currentPhase === 'round') {
    // Check if this is fantasyland mode (14 cards in lastBatch)
    if (lastBatch.length === 14) {
      // Fantasyland mode: must place all 14 cards, no discards
      if (myHand.length > 0) {
        return alert('In Fantasy Land, you must place all 14 cards.');
      }
      staged.discard = null; // No discard in fantasyland
    } else if (lastBatch.length === 5) {
      // Round 1: must place all 5 cards, no discard
      if (myHand.length > 0) {
        return alert('In Round 1, you must place all 5 cards.');
      }
      staged.discard = null; // No discard in round 1
    } else if (lastBatch.length === 3) {
      // Rounds 2-5: must place exactly 2 of the 3 new cards; leftover auto-discarded
      const placedFromBatch = staged.placements
        .filter(p => lastBatch.includes(p.card))
        .map(p => p.card);

      if (!staged.discard) {
        const leftover = lastBatch.filter(c => !placedFromBatch.includes(c));
        if (leftover.length !== 1) {
          return alert('Place exactly 2 of the 3 new cards.');
        }
        const toDiscard = leftover[0];
        const idx = myHand.indexOf(toDiscard);
        if (idx !== -1) myHand.splice(idx, 1);
        staged.discard = toDiscard;
      }
    }
  }

  // send to server
  socket.emit("action:ready", {
    roomId,
    placements: staged.placements,
    discard: staged.discard,
    userId: myUserId
  });

  // optimistic commit
  for (const p of staged.placements) myBoard[p.row].push(p.card);
  if (staged.discard) myDiscards.push(staged.discard);

  // IMPORTANT: clear the current batch only AFTER committing
  lastBatch = [];

  // reset staging and refresh UI
  staged = { placements: [], discard: null };
  renderHand();
  refreshBoard();
};

    // scoreboard / reveal
    function renderPlayerInfo() {
      if (!roomState || !roomState.players) return;
      
      const playerInfo = $('playerInfo');
      playerInfo.innerHTML = '';
      
      Object.values(roomState.players).forEach(player => {
        const playerDiv = document.createElement('div');
        playerDiv.style.marginBottom = '8px';
        playerDiv.style.padding = '6px';
        playerDiv.style.border = '1px solid #2a3244';
        playerDiv.style.borderRadius = '6px';
        playerDiv.style.backgroundColor = player.userId === myUserId ? '#1b2030' : '#0b0e17';
        
        const nameSpan = document.createElement('div');
        nameSpan.style.fontWeight = 'bold';
        nameSpan.style.color = '#e7e8ea';
        nameSpan.textContent = player.name || player.userId;
        
        const infoSpan = document.createElement('div');
        infoSpan.style.color = '#9aa3b2';
        infoSpan.style.fontSize = '12px';
        
        if (isRanked && player.tableChips !== undefined) {
          infoSpan.textContent = `${player.tableChips} chips`;
        } else {
          infoSpan.textContent = `Score: ${player.score || 0}`;
        }
        
        playerDiv.appendChild(nameSpan);
        playerDiv.appendChild(infoSpan);
        playerInfo.appendChild(playerDiv);
      });
    }
    
    function renderScoreboard(names) {
      const tbody = $('scoreboard').querySelector('tbody'); tbody.innerHTML='';
      [...totals.entries()].sort((a,b)=>b[1]-a[1]).forEach(([uid,score])=>{
        const tr=document.createElement('tr'); const tdN=document.createElement('td'); const tdS=document.createElement('td');
        tdN.textContent = names.get(uid) || uid.slice(0,8); tdS.textContent = String(score);
        tr.appendChild(tdN); tr.appendChild(tdS); tbody.appendChild(tr);
      });
    }
    function tinyCardsDiv(cards){ const d=document.createElement('div'); cards.forEach(c=>d.appendChild(cardEl(c))); return d; }
    function boardBlock(title, board, valid, reason){
      const wrap=document.createElement('div'); wrap.className='reveal-board';
      const h=document.createElement('div'); h.innerHTML = `<strong>${title}</strong> ${valid?'':`<span class="rubric">[FOUL: ${reason}]</span>`}`; wrap.appendChild(h);
      const tbl=document.createElement('table'); const tb=document.createElement('tbody');
      const mk=(label,arr)=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${label}</td><td></td>`; tr.children[1].appendChild(tinyCardsDiv(arr)); tb.appendChild(tr); };
      mk('Top',board.top); mk('Middle',board.middle); mk('Bottom',board.bottom);
      tbl.appendChild(tb); wrap.appendChild(tbl); return wrap;
    }
    function renderRevealPanel(meId, payload){
      const names = new Map(); for (const b of payload.boards) names.set(b.userId,b.name);
      // roll totals
      for (const [uid,pts] of Object.entries(payload.results||{})) totals.set(uid,(totals.get(uid)||0)+pts);
      renderScoreboard(names);

      const panel = $('revealPanel'); panel.innerHTML='';
      // boards (mine first)
      [...payload.boards].sort((a,b)=>a.userId===meId?-1:b.userId===meId?1:0).forEach(b=>{
        panel.appendChild(boardBlock(b.name,b.board,b.valid,b.reason));
      });

      // my pairwise
      const myPairs = (payload.pairwise||[]).filter(p=>p.aUserId===meId||p.bUserId===meId);
      if (myPairs.length){
        const head=document.createElement('div'); head.innerHTML='<div style="margin-top:10px;"><strong>Score breakdown</strong></div>'; panel.appendChild(head);
      }
      myPairs.forEach(p=>{
        const mine = p.aUserId===meId ? p.a : p.b;
        const opp  = p.aUserId===meId ? p.b : p.a;
        const oppId= p.aUserId===meId ? p.bUserId : p.aUserId;
        
        // Calculate line scores with royalties
        const getLineScore = (d, line) => {
          const lineScore = d.lines[line] || 0;
          const royaltyScore = d.royaltiesBreakdown?.[line] || 0;
          return lineScore + royaltyScore;
        };
        
        const mineTop = getLineScore(mine, 'top');
        const mineMiddle = getLineScore(mine, 'middle');
        const mineBottom = getLineScore(mine, 'bottom');
        const mineTotal = mineTop + mineMiddle + mineBottom;
        
        const oppTop = getLineScore(opp, 'top');
        const oppMiddle = getLineScore(opp, 'middle');
        const oppBottom = getLineScore(opp, 'bottom');
        const oppTotal = oppTop + oppMiddle + oppBottom;
        
        // Calculate difference and chip conversion
        const difference = mineTotal - oppTotal;
        const chipDifference = difference * 10;
        
        const sec=document.createElement('div');
        sec.innerHTML = `
          <div style="margin-top:10px;margin-bottom:8px;padding:8px;background:#1b2030;border-radius:8px;border:1px solid #2a3244;">
            <div style="margin-bottom:8px;"><strong>Vs ${names.get(oppId) || oppId.slice(0,8)}</strong></div>
            
            <!-- Line Scores -->
            <div style="margin-bottom:12px;">
              <div style="font-weight:600;margin-bottom:6px;color:#9aa3b2;">Line Scores:</div>
              <table style="width:100%;font-size:14px;">
                <thead><tr><th style="text-align:left;">Line</th><th style="text-align:right;">You</th><th style="text-align:right;">Opponent</th></tr></thead>
                <tbody>
                  <tr><td>Top</td><td style="text-align:right;">${mineTop>=0?'+':''}${mineTop}</td><td style="text-align:right;">${oppTop>=0?'+':''}${oppTop}</td></tr>
                  <tr><td>Middle</td><td style="text-align:right;">${mineMiddle>=0?'+':''}${mineMiddle}</td><td style="text-align:right;">${oppMiddle>=0?'+':''}${oppMiddle}</td></tr>
                  <tr><td>Bottom</td><td style="text-align:right;">${mineBottom>=0?'+':''}${mineBottom}</td><td style="text-align:right;">${oppBottom>=0?'+':''}${oppBottom}</td></tr>
                  <tr style="border-top:1px solid #2a3244;font-weight:600;">
                    <td>Total</td><td style="text-align:right;">${mineTotal>=0?'+':''}${mineTotal}</td><td style="text-align:right;">${oppTotal>=0?'+':''}${oppTotal}</td></tr>
                </tbody>
              </table>
            </div>
            
            <!-- Difference -->
            <div style="margin-bottom:8px;padding-top:8px;border-top:1px solid #2a3244;">
              <div style="font-weight:600;margin-bottom:4px;color:#9aa3b2;">Difference:</div>
              <div style="font-size:16px;font-weight:700;text-align:center;color:${difference>=0?'#7ee787':'#ff6b6b'}">
                ${difference>=0?'+':''}${difference} points
              </div>
            </div>
            
            ${isRanked ? `
            <!-- Chip Conversion for Ranked Matches -->
            <div style="padding-top:8px;border-top:1px solid #2a3244;">
              <div style="font-weight:600;margin-bottom:4px;color:#9aa3b2;">Chip Conversion (1 point = 10 chips):</div>
              <div style="font-size:16px;font-weight:700;text-align:center;color:${chipDifference>=0?'#7ee787':'#ff6b6b'}">
                ${chipDifference>=0?'+':''}${chipDifference} chips
              </div>
            </div>
            ` : ''}
          </div>`;
        panel.appendChild(sec);
      });
    }

    // socket
    function setPhase(p){ currentPhase=p||'—'; $('phase').textContent=currentPhase; $('ready').disabled=!canSet(); }
    function setCurrentRound(r){ $('currentRound').textContent=r||'—'; }
    function log(m){ $('log').textContent += m + "\n"; }

    socket = io("/", { auth:{ token } });
    socket.on('connect', () => {
      $('conn').textContent='connected';
      $('roomPill').textContent = roomId;
      
      // Check if this is a ranked match (from URL parameter)
      const urlParams = new URLSearchParams(window.location.search);
      isRanked = urlParams.get('ranked') === 'true';
      
      if (!isRanked) {
        // Only join room if it's not a ranked match (ranked matches auto-join)
        socket.emit("room:join", { roomId, name: myName });
      }
      
      // Reset next round ready state
      nextRoundReady.clear();
      updateStartButton();
    });
    socket.on('disconnect', ()=> $('conn').textContent='disconnected');
    socket.on("auth:ok", (x)=>{ myUserId = x?.userId || myUserId; });

    socket.on("room:state", (s)=>{ 
      console.log("🎯 WEB APP: Received room:state event:", s);
      roomState = s; // Store full room state
      isRanked = s.isRanked || false; // Track if this is a ranked match
      setPhase(s.phase); 
      setCurrentRound(s.currentRound);
      renderPlayerInfo(); // Update player info display
      log("STATE\n"+JSON.stringify(s,null,2)); 
      updateStartButton();
    });
    socket.on("round:start", ({round})=>{
      console.log("Round start:", round);
      myBoard={top:[],middle:[],bottom:[]}; myDiscards=[]; staged={placements:[],discard:null}; lastBatch=[];
      $('revealPanel').textContent='—'; renderHand(); refreshBoard(); log("START round "+round);
      // Reset next round ready state
      nextRoundReady.clear();
      updateStartButton();
    });
    socket.on("round:deal", ({cards, fantasyland, round})=>{
      console.log("🎯 WEB APP: Received round:deal event:", {cards, fantasyland, round});
      lastBatch = cards.slice(); 
      myHand = myHand.concat(cards); 
      renderHand();
      
      if (fantasyland) {
        // Fantasyland mode: 14 cards, no discard button, 2 rows of 7 cards
        log("FANTASY LAND MODE: 14 cards dealt");
        $('ready').disabled = !canSetFantasyland();
        
        // Hide discard zone for fantasyland
        $('zoneDiscard').style.display = 'none';
        
        // Update UI to show fantasyland mode
        document.body.style.backgroundColor = '#fff3cd';
        setTimeout(() => {
          document.body.style.backgroundColor = '';
        }, 1000);
      } else {
        // Normal mode: check if this is round 1 (5 cards) or other rounds (3 cards)
        if (round === 1) {
          // Round 1: 5 cards, must place all 5
          log("ROUND 1: 5 cards dealt, must place all");
          $('ready').disabled = !canSet();
          $('zoneDiscard').style.display = 'none'; // No discard in round 1
        } else {
          // Rounds 2-5: 3 cards, place 2 discard 1
          log(`ROUND ${round}: 3 cards dealt, place 2 discard 1`);
          $('ready').disabled = !canSet();
          $('zoneDiscard').style.display = 'block';
        }
      }
      
      log("DEAL "+JSON.stringify(cards) + (fantasyland ? " (FANTASY LAND)" : ` (ROUND ${round})`));
    });
    socket.on("round:reveal", (payload)=>{
      log("REVEAL\n"+JSON.stringify(payload,null,2));
      if (myUserId) renderRevealPanel(myUserId, payload);
      // reset staged so next hand starts clean
      staged={placements:[],discard:null}; $('ready').disabled=true;
      // Reset next round ready state
      nextRoundReady.clear();
      updateStartButton();
    });

    socket.on("round:next-ready", (data) => {
      nextRoundReady.clear();
      if (data?.readyPlayers) {
        data.readyPlayers.forEach(id => nextRoundReady.add(id));
      }
      updateStartButton();
      log("Next round ready update: " + [...nextRoundReady].join(', '));
    });

    // Function to update start button text and state
    function updateStartButton() {
      const startBtn = $('start');
      if (currentPhase === 'lobby') {
        if (nextRoundReady.has(myUserId)) {
          startBtn.textContent = 'Waiting for opponent...';
          startBtn.disabled = true;
        } else {
          startBtn.textContent = 'Ready';
          startBtn.disabled = false;
        }
      } else if (currentPhase === 'reveal') {
        if (nextRoundReady.has(myUserId)) {
          startBtn.textContent = 'Waiting for opponent...';
          startBtn.disabled = true;
        } else {
          startBtn.textContent = 'Next Round';
          startBtn.disabled = false;
        }
      } else {
        startBtn.textContent = 'Start Round';
        startBtn.disabled = false;
      }
    }

    // Handle auto-commit notification
    socket.on("action:applied", (data) => {
      console.log("Action applied received:", data);
      
      if (data.autoCommitted) {
        console.log("🎯 AUTO-COMMIT PUNISHMENT DETECTED!");
        console.log("Previous state:", {
          hand: myHand,
          board: myBoard,
          discards: myDiscards,
          staged: staged
        });
        
        // Update local state with auto-committed cards
        myBoard = data.board;
        myHand = data.hand;
        myDiscards = data.discards;
        
        // Clear staged state since cards were auto-committed
        staged = { placements: [], discard: null };
        lastBatch = [];
        
        console.log("New state after auto-commit:", {
          hand: myHand,
          board: myBoard,
          discards: myDiscards,
          staged: staged
        });
        
        // Update UI
        renderHand();
        refreshBoard();
        
        // Add visual feedback
        log("⏰ TIMEOUT PUNISHMENT: Cards auto-committed!");
        log(`Board updated: Top(${myBoard.top.length}), Middle(${myBoard.middle.length}), Bottom(${myBoard.bottom.length})`);
        if (myDiscards.length > 0) {
          log(`Discarded: ${myDiscards.join(', ')}`);
        }
        
        // Add visual flash effect to show auto-commit happened
        document.body.style.backgroundColor = '#ff4444';
        setTimeout(() => {
          document.body.style.backgroundColor = '';
        }, 500);
      }
    });


    socket.on("error:msg", (e)=> log("ERROR "+e.message));
  </script>
</body>
</html>
